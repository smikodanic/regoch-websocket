var O=Object.defineProperty;var w=(b,y)=>O(b,"name",{value:y,configurable:!0});(()=>{var b={375:m=>{class c{generateID(){const n=Math.random().toString().replace("0.","").substring(0,3);return new Date().toISOString().replace(/\-/g,"").replace(/\:/g,"").replace("T","").replace("Z","").replace(".","")+n}nowTime(){const e=new Date;return new Intl.DateTimeFormat("en-us",{weekday:"long",year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric",fractionalSecondDigits:3,hour12:!1,timeZone:"UTC"}).format(e)}async sleep(e){await new Promise(n=>setTimeout(n,e))}printBuffer(e){console.log(e.toString("hex").match(/../g).join(" "))}tableOfBytes(e,n){let a=e.toString("hex").match(/../g);return a=a.map((u,t)=>(t===0&&(u=`
 `+u),(t+1)%n===0&&(u+=`
`),u)),a.join(" ")}}w(c,"Helper"),m.exports=new c},98:m=>{class c{constructor(){this.delimiter=""}incoming(e){let n=!1,a;try{e=e.replace(this.delimiter,""),a=JSON.parse(e);const l=Object.keys(a);n=this._testFields(l)}catch{n=!1}if(n)return a;throw new Error(`Incoming message doesn't have valid "jsonRWS" subprotocol format. msg:: "${e}"`)}outgoing(e){const n=Object.keys(e);if(this._testFields(n))return JSON.stringify(e)+this.delimiter;throw new Error(`Outgoing message doesn't have valid "jsonRWS" subprotocol format. msg:: ${JSON.stringify(e)}`)}async processing(e,n,a,l,u){const t=e.id,o=e.from,s=e.to,i=e.cmd,d=e.payload;if(i==="socket/sendone"){const r=e.to,h=await l.findOne({id:r});await a.sendOne(e,h)}else if(i==="socket/send"){const r=s.map(p=>p),h=await l.find({id:{$in:r}});await a.send(e,h)}else if(i==="socket/broadcast")await a.broadcast(e,n);else if(i==="socket/sendall")await a.sendAll(e);else if(i==="socket/nick"){const r=e.payload;try{await l.setNick(n,r),e.payload=n.extension.nickname}catch(h){e.cmd="error",e.payload=h.message}n.extension.sendSelf(e)}else if(i==="room/enter"){const r=d;l.roomEnter(n,r),e.payload=`Entered in the room '${r}'`,n.extension.sendSelf(e)}else if(i==="room/exit"){const r=d;l.roomExit(n,d),e.payload=`Exited from the room '${r}'`,n.extension.sendSelf(e)}else if(i==="room/exitall")l.roomExitAll(n),e.payload="Exited from all rooms",n.extension.sendSelf(e);else if(i==="room/send"){const r=s;await a.sendRoom(e,n,r)}else if(i==="route")u.emit("route",e,n,a,l,u);else if(i==="question/socket/id")e.payload=n.extension.id,n.extension.sendSelf(e);else if(i==="question/socket/list"){const h=(await l.find()).map(p=>({id:p.extension.id,nickname:p.extension.nickname}));e.payload=h,n.extension.sendSelf(e)}else if(i==="question/room/list"){const r=await l.roomList();e.payload=r,n.extension.sendSelf(e)}else if(i==="question/room/listmy"){const r=await l.roomListOf(e.from);e.payload=r,n.extension.sendSelf(e)}}_testFields(e){const n=["id","from","to","cmd","payload"],a=["id","from","to","cmd"];let l=!0;for(const u of e)if(n.indexOf(u)===-1){l=!1;break}for(const u of a)if(e.indexOf(u)===-1){l=!1;break}return l}}w(c,"JsonRWS"),m.exports=new c},554:m=>{class c{constructor(){this.delimiter=""}incoming(e){return e=e.replace(this.delimiter,""),e}outgoing(e){let n=e;return typeof e=="object"&&(n=JSON.stringify(e)),n+=this.delimiter,n}async process(){}}w(c,"Raw"),m.exports=new c}},y={};function k(m){var c=y[m];if(c!==void 0)return c.exports;var f=y[m]={exports:{}};return b[m](f,f.exports,k),f.exports}w(k,"__webpack_require__");var v={};(()=>{"use strict";class m{constructor(){this.activeOns=[]}emit(t,o={}){const s=new CustomEvent(t,{detail:o});window.dispatchEvent(s)}on(t,o){const s=w(i=>{const d=this._getDetailValues(i.detail);o.call(null,...d)},"listenerWindow");this._removeOne(t,o),this.activeOns.push({eventName:t,listener:o,listenerWindow:s}),window.addEventListener(t,s)}once(t,o){const s=w(i=>{const d=this._getDetailValues(i.detail);o.call(null,...d),this._removeOne(t,o,s)},"listenerWindow");window.addEventListener(t,s,{once:!0})}off(t,o){this._removeOne(t,o)}offAll(t){let o=0;for(const s of this.activeOns)s.eventName===t&&(window.removeEventListener(s.eventName,s.listenerWindow),this.activeOns.splice(o,1)),o++}getListeners(){return{...this.activeOns}}_removeOne(t,o){if(!o)throw new Error("eventEmitter._removeOne Error: listener is not defined");let s=0;for(const i of this.activeOns)i.eventName===t&&i.listener.toString()===o.toString()&&(window.removeEventListener(i.eventName,i.listenerWindow),this.activeOns.splice(s,1)),s++}_getDetailValues(t){return t?Object.values(t):[]}}w(m,"EventEmitter");const c=new m;var f=k(98),e=k(554),n=k(375);class a{constructor(t){if(this.wcOpts=t,!t.wsURL||!/^ws:\/\//.test(t.wsURL))throw new Error("Bad websocket URL");t.connectTimeout||(this.wcOpts.connectTimeout=8e3),t.reconnectAttempts===void 0&&(this.wcOpts.reconnectAttempts=6),t.reconnectDelay===void 0&&(this.wcOpts.reconnectDelay=5e3),t.questionTimeout===void 0&&(this.wcOpts.questionTimeout=13e3),t.subprotocols||(this.wcOpts.subprotocols=["jsonRWS","raw"]),t.debug||(this.wcOpts.debug=!1),t.debug_DataParser||(this.wcOpts.debug_DataParser=!1),this.wsocket,this.socketID,this.attempt=1,this.subprotocolLib}connect(){this.socketID=n.generateID();let t=this.wcOpts.wsURL;return/\?[a-zA-Z0-9]/.test(t)?t+=`&socketID=${this.socketID}`:t+=`socketID=${this.socketID}`,this.wsocket=new WebSocket(t,this.wcOpts.subprotocols),this.onEvents(),new Promise(o=>{c.once("connected",()=>{o(this.wsocket)})})}disconnect(){this.wsocket&&this.wsocket.close(),this.blockReconnect()}async reconnect(){const t=this.wcOpts.reconnectAttempts,o=this.wcOpts.reconnectDelay;this.attempt<=t&&(await n.sleep(o),this.connect(),console.log(`Reconnect attempt #${this.attempt} of ${t} in ${o}ms`),this.attempt++)}blockReconnect(){this.attempt=this.wcOpts.reconnectAttempts+1}onEvents(){this.wsocket.onopen=async t=>{console.log(`WS Connection opened -- socketID: ${this.socketID}, subprotocol(handshaked): "${this.wsocket.protocol}"`),this.onMessage(),this.attempt=1,!!this.wsocket&&this.wsocket.protocol==="raw"?this.subprotocolLib=e:!!this.wsocket&&this.wsocket.protocol==="jsonRWS"?this.subprotocolLib=f:this.subprotocolLib=e,c.emit("connected")},this.wsocket.onclose=t=>{console.log("WS Connection closed"),delete this.wsocket,delete this.socketID,this.reconnect(),c.emit("disconnected")},this.wsocket.onerror=t=>{}}onMessage(){if(!this.wsocket)return;const t=this.wsocket.protocol;this.wsocket.addEventListener("message",o=>{try{const s=o.data;if(this._debugger("Received::",s),!new RegExp(this.subprotocolLib.delimiter).test(s))return;const d=this.subprotocolLib.incoming(s),r={msg:d,msgSTR:s};d.cmd==="route"&&t==="jsonRWS"?c.emit("route",r):d.cmd==="server-error"&&t==="jsonRWS"?(this.blockReconnect(),c.emit("server-error",r)):/^question\//.test(d.cmd)&&t==="jsonRWS"?c.emit("question",r):c.emit("message",r)}catch(s){c.emit("message-error",s)}})}async carryOut(t,o,s){const i=n.generateID(),d=this.socketID;if(!Array.isArray(t)&&typeof t!="string")throw new Error('ERRcarryOut: "to" argument must be string');if(Array.isArray(t)){for(const p of t)if(typeof p!="string")throw new Error('ERRcarryOut: "to" argument must be string')}const r={id:i,from:d,to:t,cmd:o,payload:s},h=f.outgoing(r);return await this.socketWrite(h),this._debugger("Sent::",h),r}async socketWrite(t){if(await new Promise(o=>setTimeout(o,0)),!!this.wsocket&&this.wsocket.readyState===1)this.wsocket.send(t);else throw new Error("Socket is not writeble or doesn't exist")}async sendOne(t,o){const s="socket/sendone";return await this.carryOut(t,s,o)}async send(t,o){const s="socket/send";return await this.carryOut(t,s,o)}async broadcast(t){const o="0",s="socket/broadcast";return await this.carryOut(o,s,t)}async sendAll(t){const o="0",s="socket/sendall";return await this.carryOut(o,s,t)}async question(t){const o=this.socketID,s=void 0;return await this.carryOut(o,t,s),new Promise(async(i,d)=>{const r=w(h=>{h.cmd===t&&i(h)},"listener");this.once("question",r),await n.sleep(this.wcOpts.questionTimeout),this.off("question",r),d(new Error(`No answer for the question: ${t}`))})}async questionSocketId(){const t=await this.question("question/socket/id");return this.socketID=t.payload,this.socketID}async questionSocketList(){return(await this.question("question/socket/list")).payload}async questionRoomList(){return(await this.question("question/room/list")).payload}async questionRoomListmy(){return(await this.question("question/room/listmy")).payload}async roomEnter(t){const o="0",s="room/enter",i=t;return await this.carryOut(o,s,i)}async roomExit(t){const o="0",s="room/exit",i=t;return await this.carryOut(o,s,i)}async roomExitAll(){const t="0",o="room/exitall";return await this.carryOut(t,o,void 0)}async roomSend(t,o){const s=t,i="room/send";return await this.carryOut(s,i,o)}async setNick(t){const o="0",s="socket/nick",i=t;return await this.carryOut(o,s,i)}async route(t,o){const s="0",i="route",d={uri:t,body:o};return await this.carryOut(s,i,d)}on(t,o){c.on(t,o)}once(t,o){return c.once(t,o)}off(t,o){return c.off(t,o)}offAll(t){return c.offAll(t)}_debugger(...t){const o=t.join("");this.wcOpts.debug&&console.log(o)}}w(a,"Client13jsonRWS");const l=null;window.regochWebsocket={Client13jsonRWS:a}})()})();

//# sourceMappingURL=client13jsonRWS.min.js.map