!function(){return function t(e,o,s){function n(r,c){if(!o[r]){if(!e[r]){var a="function"==typeof require&&require;if(!c&&a)return a(r,!0);if(i)return i(r,!0);var l=new Error("Cannot find module '"+r+"'");throw l.code="MODULE_NOT_FOUND",l}var u=o[r]={exports:{}};e[r][0].call(u.exports,function(t){return n(e[r][1][t]||t)},u,u.exports,t,e,o,s)}return o[r].exports}for(var i="function"==typeof require&&require,r=0;r<s.length;r++)n(s[r]);return n}}()({1:[function(t,e,o){const s=t("./auxillary/eventEmitter"),n=t("../../lib/subprotocol/jsonRWS"),i=t("../../lib/subprotocol/raw"),r=t("../../lib/helper");class c{constructor(t){if(this.wcOpts=t,!t.wsURL||!/^ws:\/\//.test(t.wsURL))throw new Error("Bad websocket URL");t.connectTimeout||(this.wcOpts.connectTimeout=8e3),t.reconnectAttempts||(this.wcOpts.reconnectAttempts=5),t.reconnectDelay||(this.wcOpts.reconnectDelay=3e3),t.questionTimeout||(this.wcOpts.questionTimeout=3e3),t.subprotocols||(this.wcOpts.subprotocols=["jsonRWS","raw"]),t.autodelayFactor||(this.wcOpts.autodelayFactor=500),t.debug||(this.wcOpts.debug=!1),t.debug_DataParser||(this.wcOpts.debug_DataParser=!1),this.wsocket,this.socketID,this.attempt=1,this.subprotocolLib}connect(){this.socketID=r.generateID();let t=this.wcOpts.wsURL;return/\?[a-zA-Z0-9]/.test(t)?t+=`&socketID=${this.socketID}`:t+=`socketID=${this.socketID}`,this.wsocket=new WebSocket(t,this.wcOpts.subprotocols),this.onEvents(),new Promise(t=>{s.once("connected",()=>{t(this.wsocket)})})}disconnect(){this.wsocket&&this.wsocket.close(),this.blockReconnect()}async reconnect(){const t=this.wcOpts.reconnectAttempts,e=this.wcOpts.reconnectDelay;this.attempt<=t&&(await r.sleep(e),this.connect(),console.log(`Reconnect attempt #${this.attempt} of ${t} in ${e}ms`),this.attempt++)}blockReconnect(){this.attempt=this.wcOpts.reconnectAttempts+1}onEvents(){this.wsocket.onopen=(async t=>{console.log(`WS Connection opened -- socketID: ${this.socketID}, subprotocol(handshaked): "${this.wsocket.protocol}"`),this.onMessage(),this.attempt=1,this.wsocket&&"raw"===this.wsocket.protocol?this.subprotocolLib=i:this.wsocket&&"jsonRWS"===this.wsocket.protocol?this.subprotocolLib=n:this.subprotocolLib=i,s.emit("connected")}),this.wsocket.onclose=(t=>{console.log("WS Connection closed"),delete this.wsocket,delete this.socketID,this.reconnect(),s.emit("disconnected")}),this.wsocket.onerror=(t=>{})}onMessage(){if(!this.wsocket)return;const t=this.wsocket.protocol;this.wsocket.addEventListener("message",e=>{try{const o=e.data;if(this._debugger("Received::",o),!new RegExp(this.subprotocolLib.delimiter).test(o))return;const n=this.subprotocolLib.incoming(o),i={msg:n,msgSTR:o};"route"===n.cmd&&"jsonRWS"===t?s.emit("route",i):"server-error"===n.cmd&&"jsonRWS"===t?(this.blockReconnect(),s.emit("server-error",i)):/^question\//.test(n.cmd)&&"jsonRWS"===t?s.emit("question",i):s.emit("message",i)}catch(t){s.emit("message-error",t)}})}async carryOut(t,e,o){const s=r.generateID(),i=this.socketID;if(!Array.isArray(t)&&"string"!=typeof t)throw new Error('ERRcarryOut: "to" argument must be string');if(Array.isArray(t))for(const e of t)if("string"!=typeof e)throw new Error('ERRcarryOut: "to" argument must be string');const c={id:s,from:i,to:t,cmd:e,payload:o},a=n.outgoing(c);return await this.socketWrite(a),this._debugger("Sent::",a),c}async socketWrite(t){if(await new Promise(t=>setTimeout(t,0)),!this.wsocket||1!==this.wsocket.readyState)throw new Error("Socket is not writeble or doesn't exist");this.wsocket.send(t)}async sendOne(t,e){return await this.carryOut(t,"socket/sendone",e)}async send(t,e){return await this.carryOut(t,"socket/send",e)}async broadcast(t){return await this.carryOut("0","socket/broadcast",t)}async sendAll(t){return await this.carryOut("0","socket/sendall",t)}async question(t){const e=this.socketID;return await this.carryOut(e,t,void 0),new Promise(async(e,o)=>{const s=o=>{o.cmd===t&&e(o)};this.once("question",s),await r.sleep(this.wcOpts.questionTimeout),this.off("question",s),o(new Error(`No answer for the question: ${t}`))})}async questionSocketId(){const t=await this.question("question/socket/id");return this.socketID=t.payload,this.socketID}async questionSocketList(){return(await this.question("question/socket/list")).payload}async questionRoomList(){return(await this.question("question/room/list")).payload}async questionRoomListmy(){return(await this.question("question/room/listmy")).payload}async roomEnter(t){const e=t;return await this.carryOut("0","room/enter",e)}async roomExit(t){const e=t;return await this.carryOut("0","room/exit",e)}async roomExitAll(){return await this.carryOut("0","room/exitall",void 0)}async roomSend(t,e){const o=t;return await this.carryOut(o,"room/send",e)}async setNick(t){const e=t;return await this.carryOut("0","socket/nick",e)}async route(t,e){const o={uri:t,body:e};return await this.carryOut("0","route",o)}on(t,e){s.on(t,e)}once(t,e){return s.once(t,e)}off(t,e){return s.off(t,e)}offAll(t){return s.offAll(t)}_debugger(...t){const e=t.join("");this.wcOpts.debug&&console.log(e)}}void 0!==e&&(e.exports=c),"undefined"!=typeof window&&(window.regochWebsocket={Client13jsonRWS:c})},{"../../lib/helper":3,"../../lib/subprotocol/jsonRWS":4,"../../lib/subprotocol/raw":5,"./auxillary/eventEmitter":2}],2:[function(t,e,o){e.exports=new class{constructor(){this.activeOns=[]}emit(t,e={}){const o=new CustomEvent(t,{detail:e});window.dispatchEvent(o)}on(t,e){const o=t=>{const o=this._getDetailValues(e,t.detail);e.call(null,...o)};this._removeOne(t,e),this.activeOns.push({eventName:t,listener:e,listenerWindow:o}),window.addEventListener(t,o)}once(t,e){const o=s=>{const n=this._getDetailValues(e,s.detail);e.call(null,...n),this._removeOne(t,e,o)};window.addEventListener(t,o,{once:!0})}off(t,e){this._removeOne(t,e)}offAll(t){let e=0;for(const o of this.activeOns)o.eventName===t&&(window.removeEventListener(o.eventName,o.listenerWindow),this.activeOns.splice(e,1)),e++}getListeners(){return{...this.activeOns}}_removeOne(t,e){if(!e)throw new Error("eventEmitter._removeOne Error: listener is not defined");let o=0;for(const s of this.activeOns)s.eventName===t&&s.listener.toString()===e.toString()&&(window.removeEventListener(s.eventName,s.listenerWindow),this.activeOns.splice(o,1)),o++}_getDetailValues(t,e){if(!t)throw new Error("eventEmitter._getDetailValues Error: listener is not defined");const o=/(.+)\s*\=\>/,s=/function\s*\((.*)\)/,n=t.toString();let i=n.match(/\((.*)\)\s*\=\>/);if(i||(i=n.match(o)),i||(i=n.match(s)),i)return i[1].split(",").map(t=>t.trim()).map(t=>e[t]);console.error(`_getDetailValues Err:: The listener is not valid ! listener:: ${t.toString()}`)}}},{}],3:[function(t,e,o){e.exports=new class{generateID(){const t=Math.random().toString().replace("0.","").substring(0,3);return(new Date).toISOString().replace(/\-/g,"").replace(/\:/g,"").replace("T","").replace("Z","").replace(".","")+t}nowTime(){const t=new Date;return new Intl.DateTimeFormat("en-us",{weekday:"long",year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric",fractionalSecondDigits:3,hour12:!1,timeZone:"UTC"}).format(t)}async sleep(t){await new Promise(e=>setTimeout(e,t))}printBuffer(t){console.log(t.toString("hex").match(/../g).join(" "))}tableOfBytes(t,e){let o=t.toString("hex").match(/../g);return(o=o.map((t,o)=>(0===o&&(t="\n "+t),(o+1)%e==0&&(t+="\n"),t))).join(" ")}}},{}],4:[function(t,e,o){e.exports=new class{constructor(){this.delimiter=""}incoming(t){let e,o=!1;try{t=t.replace(this.delimiter,""),e=JSON.parse(t);const s=Object.keys(e);o=this._testFields(s)}catch(t){o=!1}if(o)return e;throw new Error(`Incoming message doesn't have valid "jsonRWS" subprotocol format. msg:: "${t}"`)}outgoing(t){const e=Object.keys(t);if(this._testFields(e))return JSON.stringify(t)+this.delimiter;throw new Error(`Outgoing message doesn't have valid "jsonRWS" subprotocol format. msg:: ${JSON.stringify(t)}`)}async processing(t,e,o,s,n){t.id,t.from;const i=t.to,r=t.cmd,c=t.payload;if("socket/sendone"===r){const e=t.to,n=await s.findOne({id:e});await o.sendOne(t,n)}else if("socket/send"===r){const e=i.map(t=>t),n=await s.find({id:{$in:e}});await o.send(t,n)}else if("socket/broadcast"===r)await o.broadcast(t,e);else if("socket/sendall"===r)await o.sendAll(t);else if("socket/nick"===r){const o=t.payload;try{await s.setNick(e,o),t.payload=e.extension.nickname}catch(e){t.cmd="error",t.payload=e.message}e.extension.sendSelf(t)}else if("room/enter"===r){const o=c;s.roomEnter(e,o),t.payload=`Entered in the room '${o}'`,e.extension.sendSelf(t)}else if("room/exit"===r){const o=c;s.roomExit(e,c),t.payload=`Exited from the room '${o}'`,e.extension.sendSelf(t)}else if("room/exitall"===r)s.roomExitAll(e),t.payload="Exited from all rooms",e.extension.sendSelf(t);else if("room/send"===r){const s=i;await o.sendRoom(t,e,s)}else if("route"===r)n.emit("route",t,e,o,s,n);else if("question/socket/id"===r)t.payload=e.extension.id,e.extension.sendSelf(t);else if("question/socket/list"===r){const o=(await s.find()).map(t=>({id:t.extension.id,nickname:t.extension.nickname}));t.payload=o,e.extension.sendSelf(t)}else if("question/room/list"===r){const o=await s.roomList();t.payload=o,e.extension.sendSelf(t)}else if("question/room/listmy"===r){const o=await s.roomListOf(t.from);t.payload=o,e.extension.sendSelf(t)}}_testFields(t){const e=["id","from","to","cmd","payload"],o=["id","from","to","cmd"];let s=!0;for(const o of t)if(-1===e.indexOf(o)){s=!1;break}for(const e of o)if(-1===t.indexOf(e)){s=!1;break}return s}}},{}],5:[function(t,e,o){e.exports=new class{constructor(){this.delimiter=""}incoming(t){return t=t.replace(this.delimiter,"")}outgoing(t){let e=t;return"object"==typeof t&&(e=JSON.stringify(t)),e+=this.delimiter}async process(){}}},{}]},{},[1]);
//# sourceMappingURL=client13jsonRWS-min.js.map
