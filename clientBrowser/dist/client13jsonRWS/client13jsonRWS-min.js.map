{"version":3,"sources":["client13jsonRWS.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","eventEmitter","jsonRWS","helper","Client13jsonRWS","[object Object]","wcOpts","this","wsocket","socketID","attempt","wsURL","WebSocket","subprotocols","onEvents","Promise","resolve","once","close","blockReconnect","attempts","reconnectAttempts","delay","reconnectDelay","sleep","connect","console","log","onopen","async","openEvt","onMessage","infoSocketId","emit","onclose","closeEvt","reconnect","onerror","errorEvt","onmessage","event","msgSTR","data","debugger","msg","incoming","detail","cmd","err","error","to","carryOut","undefined","reject","questionTimeout","answer","question","payload","msgObj","id","generateID","from","outgoing","readyState","setTimeout","send","roomName","nickname","uri","body","eventName","listener","on","off","textParts","text","join","debug","window","regochWebsocket","../../lib/helper","../../lib/subprotocol/jsonRWS","./aux/eventEmitter","2","activeOns","evt","CustomEvent","dispatchEvent","listenerCB","ind","activeOn","toString","removeEventListener","splice","push","addEventListener","3","rnd","Math","random","rrr","floor","Date","toISOString","replace","now","Intl","DateTimeFormat","weekday","year","month","day","hour","minute","second","fractionalSecondDigits","hour12","timeZone","format","ms","buff","match","4","delimiter","tf","JSON","parse","msgObjProperties","Object","keys","_testFields","stringify","socket","dataTransfer","socketStorage","toSocket","findOne","sendOne","socketIDs","map","sockets","find","$in","broadcast","sendAll","setNick","extension","message","sendSelf","roomEnter","roomExit","roomExitAll","sendRoom","socket_ids_nicks","rooms","roomList","roomListOf","allowedFields","requiredFields","prop","indexOf","requiredField"],"mappings":"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","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n * Websocket Client for Browser\n * - websocket version: 13\n * - subprotocol: jsonRWS\n */\nconst eventEmitter = require('./aux/eventEmitter');\nconst jsonRWS = require('../../lib/subprotocol/jsonRWS');\nconst helper = require('../../lib/helper');\n\n\nclass Client13jsonRWS {\n\n  /**\n   * @param {{wsURL:string, questionTimeout:number, reconnectAttempts:number, reconnectDelay:number, subprotocols:string[], debug:boolean}} wcOpts - websocket client options\n   */\n  constructor(wcOpts) {\n    this.wcOpts = wcOpts; // websocket client options\n    this.wsocket; // Websocket instance https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n    this.socketID; // socket ID number, for example: 210214082949459100\n\n    this.attempt = 1; // reconnect attempt counter\n  }\n\n\n  /************* CLIENT CONNECTOR ************/\n  /**\n   * Connect to the websocket server.\n   * @returns {Promise<Socket>}\n   */\n  connect() {\n    const wsURL = this.wcOpts.wsURL; // websocket URL: ws://localhost:3211/something?authkey=TRTmrt\n    this.wsocket = new WebSocket(wsURL, this.wcOpts.subprotocols);\n\n    this.onEvents();\n\n    // return socket as promise\n    return new Promise(resolve => {\n      // eventEmitter.removeAllListeners(); // not needed if once() is used\n      eventEmitter.once('connected', () => { resolve(this.wsocket); });\n      // console.log(`\"connected\" listeners: ${eventEmitter.listenerCount('connected')}`.cliBoja('yellow'));\n    });\n  }\n\n\n  /**\n   * Disconnect from the websocket server.\n   * @returns {void}\n   */\n  disconnect() {\n    if (!!this.wsocket) { this.wsocket.close(); }\n    this.blockReconnect();\n  }\n\n\n  /**\n   * Try to reconnect the client when the socket is closed.\n   * This method is fired on every 'close' socket's event.\n   */\n  async reconnect() {\n    const attempts = this.wcOpts.reconnectAttempts;\n    const delay = this.wcOpts.reconnectDelay;\n    if (this.attempt <= attempts) {\n      await helper.sleep(delay);\n      this.connect();\n      console.log(`Reconnect attempt #${this.attempt} of ${attempts} in ${delay}ms`);\n      this.attempt++;\n    }\n  }\n\n\n  /**\n   * Block reconnect usually after disconnect() method is used.\n   */\n  blockReconnect() {\n    this.attempt = this.wcOpts.reconnectAttempts + 1;\n  }\n\n\n\n  /**\n   * Event listeners.\n   * @returns {void}\n   */\n  onEvents() {\n    this.wsocket.onopen = async (openEvt) => {\n      this.onMessage();\n      console.log('WS Connection opened');\n      this.attempt = 1;\n      this.socketID = await this.infoSocketId();\n      console.log(`socketID: ${this.socketID}`);\n      eventEmitter.emit('connected');\n    };\n\n    this.wsocket.onclose = (closeEvt) => {\n      console.log('WS Connection closed');\n      delete this.wsocket; // Websocket instance https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n      delete this.socketID;\n      this.reconnect();\n    };\n\n    this.wsocket.onerror = (errorEvt) => {\n      // console.error(errorEvt);\n    };\n  }\n\n\n\n  /************* RECEIVER ************/\n  /**\n   * Receive the message event and push it to msgStream.\n   * @returns {void}\n   */\n  onMessage() {\n    this.wsocket.onmessage = event => {\n      try {\n        const msgSTR = event.data;\n        this.debugger('Received::', msgSTR);\n        const msg = jsonRWS.incoming(msgSTR); // test against subprotocol rules and convert string to object);\n\n        const detail = {msg, msgSTR};\n        if (msg.cmd === 'route') { eventEmitter.emit('route', detail); }\n        else if (msg.cmd === 'info/socket/id') { eventEmitter.emit('question', detail); }\n        else if (msg.cmd === 'info/socket/list') { eventEmitter.emit('question', detail); }\n        else if (msg.cmd === 'info/room/list') { eventEmitter.emit('question', detail); }\n        else if (msg.cmd === 'info/room/listmy') { eventEmitter.emit('question', detail); }\n        else { eventEmitter.emit('message', detail); }\n\n      } catch (err) {\n        console.error(err);\n      }\n    };\n  }\n\n\n\n  /************* QUESTIONS ************/\n  /*** Send a question to the websocket server and wait for the answer. */\n  /**\n   * Send question and expect the answer.\n   * @param {string} cmd - command\n   * @returns {Promise<object>}\n   */\n  question(cmd) {\n    // send the question\n    const payload = undefined;\n    const to = this.socketID;\n    this.carryOut(to, cmd, payload);\n\n    // receive the answer\n    return new Promise(async (resolve, reject) => {\n      this.once('question', async (msg, msgSTR) => {\n        if (msg.cmd === cmd) { resolve(msg); }\n        else { reject(new Error('Received cmd is not same as sent cmd.')); }\n      });\n      await helper.sleep(this.wcOpts.questionTimeout);\n      reject(new Error(`No answer for the question: ${cmd}`));\n    });\n  }\n\n  /**\n   * Send question about my socket ID.\n   * @returns {Promise<number>}\n   */\n  async infoSocketId() {\n    const answer = await this.question('info/socket/id');\n    this.socketID = +answer.payload;\n    return this.socketID;\n  }\n\n  /**\n   * Send question about all socket IDs connected to the server.\n   * @returns {Promise<number[]>}\n   */\n  async infoSocketList() {\n    const answer = await this.question('info/socket/list');\n    return answer.payload;\n  }\n\n  /**\n   * Send question about all rooms in the server.\n   * @returns {Promise<{name:string, socketIds:number[]}[]>}\n   */\n  async infoRoomList() {\n    const answer = await this.question('info/room/list');\n    return answer.payload;\n  }\n\n  /**\n   * Send question about all rooms where the client was entered.\n   * @returns {Promise<{name:string, socketIds:number[]}[]>}\n   */\n  async infoRoomListmy() {\n    const answer = await this.question(`info/room/listmy`);\n    return answer.payload;\n  }\n\n\n\n\n\n\n  /************* SEND MESSAGE TO OTHER CLIENTS ************/\n  /**\n   * Send message to the websocket server if the connection is not closed (https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState).\n   * @param {number|number[]} to - final destination: 210201164339351900\n   * @param {string} cmd - command\n   * @param {any} payload - message payload\n   * @returns {void}\n   */\n  async carryOut(to, cmd, payload) {\n    const id = helper.generateID(); // the message ID\n    const from = +this.socketID; // the sender ID\n    if (!to) { to = 0; } // server ID is 0\n    const msgObj = {id, from, to, cmd, payload};\n    const msg = jsonRWS.outgoing(msgObj);\n    this.debugger('Sent::', msg);\n\n    // the message must be defined and client must be connected to the server\n    if (!!msg && !!this.wsocket && this.wsocket.readyState === 1) {\n      await new Promise(r => setTimeout(r, 0));\n      await this.wsocket.send(msg);\n    } else {\n      throw new Error('The message is not defined or the client is disconnected.');\n    }\n  }\n\n\n  /**\n   * Send message (payload) to one client.\n   * @param {number} to - 210201164339351900\n   * @param {any} msg - message sent to the client\n   * @returns {void}\n   */\n  async sendOne(to, msg) {\n    const cmd = 'socket/sendone';\n    const payload = msg;\n    await this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send message (payload) to one or more clients.\n   * @param {number[]} to - [210205081923171300, 210205082042463230]\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  async send(to, msg) {\n    const cmd = 'socket/send';\n    const payload = msg;\n    await this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send message (payload) to all clients except the sender.\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  async broadcast(msg) {\n    const to = 0;\n    const cmd = 'socket/broadcast';\n    const payload = msg;\n    await this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Send message (payload) to all clients and the sender.\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  async sendAll(msg) {\n    const to = 0;\n    const cmd = 'socket/sendall';\n    const payload = msg;\n    await this.carryOut(to, cmd, payload);\n  }\n\n\n\n  /************* ROOM ************/\n  /**\n   * Subscribe in the room.\n   * @param {string} roomName\n   * @returns {void}\n   */\n  async roomEnter(roomName) {\n    const to = 0;\n    const cmd = 'room/enter';\n    const payload = roomName;\n    await this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Unsubscribe from the room.\n   * @param {string} roomName\n   * @returns {void}\n   */\n  async roomExit(roomName) {\n    const to = 0;\n    const cmd = 'room/exit';\n    const payload = roomName;\n    await this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Unsubscribe from all rooms.\n   * @returns {void}\n   */\n  async roomExitAll() {\n    const to = 0;\n    const cmd = 'room/exitall';\n    const payload = undefined;\n    await this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Send message to the room.\n   * @param {string} roomName\n   * @param {any} msg\n   * @returns {void}\n   */\n  async roomSend(roomName, msg) {\n    const to = roomName;\n    const cmd = 'room/send';\n    const payload = msg;\n    await this.carryOut(to, cmd, payload);\n  }\n\n\n\n\n  /********* SEND MESSAGE (COMMAND) TO SERVER *********/\n  /**\n   * Setup a nick name.\n   * @param {string} nickname - nick name\n   * @returns {void}\n   */\n  async setNick(nickname) {\n    const to = 0;\n    const cmd = 'socket/nick';\n    const payload = nickname;\n    await this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send route command.\n   * @param {string} uri - route URI, for example /shop/product/55\n   * @param {any} body - body\n   * @returns {void}\n   */\n  async route(uri, body) {\n    const to = 0;\n    const cmd = 'route';\n    const payload = {uri, body};\n    await this.carryOut(to, cmd, payload);\n  }\n\n\n\n\n  /*********** LISTENERS ************/\n  /**\n   * Wrapper around the eventEmitter\n   * @param {string} eventName - event name: 'connected', 'message', 'route', 'question\n   * @param {Function} listener - callback function, for example: (msg, msgSTR) => { console.log(msgSTR); }\n   */\n  on(eventName, listener) {\n    return eventEmitter.on(eventName, event => {\n      listener.call(null, event.detail.msg, event.detail.msgSTR);\n    });\n  }\n\n  /**\n   * Wrapper around the eventEmitter\n   * @param {string} eventName - event name: 'connected', 'message', 'route', 'question\n   * @param {Function} listener - callback function, for example: (msg, msgSTR) => { console.log(msgSTR); }\n   */\n  once(eventName, listener) {\n    return eventEmitter.on(eventName, event => {\n      listener.call(null, event.detail.msg, event.detail.msgSTR);\n    });\n  }\n\n  /**\n   * Wrapper around the eventEmitter\n   * @param {string} eventName - event name: 'connected', 'message', 'route', 'question\n   */\n  off(eventName) {\n    return eventEmitter.off(eventName);\n  }\n\n\n\n  /*********** MISC ************/\n  /**\n   * Debugger. Use it as this.debug(var1, var2, var3)\n   * @returns {void}\n   */\n  debugger(...textParts) {\n    const text = textParts.join('');\n    if (this.wcOpts.debug) { console.log(text); }\n  }\n\n\n\n\n}\n\n\nwindow.regochWebsocket = { Client13jsonRWS };\nmodule.exports = Client13jsonRWS;\n\n},{\"../../lib/helper\":3,\"../../lib/subprotocol/jsonRWS\":4,\"./aux/eventEmitter\":2}],2:[function(require,module,exports){\nclass EventEmitter {\n\n  constructor() {\n    this.activeOns = []; // [{eventName:string, listenerCB:Function}]\n  }\n\n  /**\n   * Create and emit the event\n   * @param {string} eventName - event name, for example: 'pushstate'\n   * @param {any} detail - event argument\n   * @returns {void}\n   */\n  emit(eventName, detail) {\n    const evt = new CustomEvent(eventName, {detail});\n    window.dispatchEvent(evt);\n  }\n\n\n  /**\n   * Listen for the event\n   * @param {string} eventName - event name, for example: 'pushstate'\n   * @param {Function} listener - callback function with event parameter\n   * @returns {void}\n   */\n  on(eventName, listener) {\n    const listenerCB = event => { listener(event); };\n\n    // remove duplicated listeners\n    let ind = 0;\n    for (const activeOn of this.activeOns) {\n      if (activeOn.eventName === eventName && activeOn.listenerCB.toString() === listenerCB.toString()) {\n        window.removeEventListener(eventName, activeOn.listenerCB);\n        this.activeOns.splice(ind, 1);\n      }\n      ind++;\n    }\n\n    this.activeOns.push({eventName, listenerCB});\n    window.addEventListener(eventName, listenerCB);\n  }\n\n\n  /**\n   * Listen for the event only once\n   * @param {string} eventName - event name, for example: 'pushstate'\n   * @param {Function} listener - callback function with event parameter\n   * @returns {void}\n   */\n  once(eventName, listener) {\n    const listenerCB = event => {\n      listener(event);\n      window.removeEventListener(eventName, listenerCB);\n    };\n    window.addEventListener(eventName, listenerCB, {once: true});\n  }\n\n\n  /**\n   * Stop listening the event for multiple listeners defined with on().\n   * For example eventEmitter.on('msg', fja1) & eventEmitter.on('msg', fja2) then eventEmitter.off('msg') will remove fja1 and fja2 listeners.\n   * @param {string} eventName - event name, for example: 'pushstate'\n   * @returns {void}\n   */\n  off(eventName) {\n    let ind = 0;\n    for (const activeOn of this.activeOns) {\n      if (activeOn.eventName === eventName) {\n        window.removeEventListener(eventName, activeOn.listenerCB);\n        this.activeOns.splice(ind, 1);\n      }\n      ind++;\n    }\n  }\n\n\n\n  /**\n   * Get all active listeners.\n   * @returns {{eventName:string, listenerCB:Function}[]}\n   */\n  getListeners() {\n    return {...this.activeOns};\n  }\n\n\n\n}\n\n\nmodule.exports = new EventEmitter();\n\n},{}],3:[function(require,module,exports){\nclass Helper {\n\n  /**\n   * Create unique id. It's combination of timestamp and random number 'r'\n   * in format: YYMMDDHHmmssSSSrrr ---> YY year, MM month, DD day, HH hour, mm min, ss sec, SSS ms, rrr 3 random digits\n   * 18 digits in total, for example: 210129163129492100\n   * @returns {number}\n   */\n  generateID() {\n    const rnd = Math.random() * 1000;\n    const rrr = Math.floor(rnd);\n\n    const timestamp = new Date();\n    const tsp = timestamp.toISOString()\n      .replace(/^20/, '')\n      .replace(/\\-/g, '')\n      .replace(/\\:/g, '')\n      .replace('T', '')\n      .replace('Z', '')\n      .replace('.', '');\n\n    const id = +(tsp + rrr);\n    return id;\n  }\n\n\n  /**\n   * Gives now time in nice format -> Friday, 1/29/2021, 16:31:29.801\n   * @returns {string}\n   */\n  nowTime() {\n    const now = new Date();\n    const formatter = new Intl.DateTimeFormat('en-us', {\n      weekday: 'long',\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric',\n      fractionalSecondDigits: 3,\n      hour12: false,\n      timeZone: 'UTC'\n    });\n    return formatter.format(now);\n  }\n\n\n  /**\n   * Pause the code execution\n   * @param {number} ms - miliseconds\n   * @returns {Promise}\n   */\n  async sleep(ms) {\n    await new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n\n\n  /**\n   * Print all buffer values as string. The bytes are printed separately, for example byte 81, byte 7e ...etc\n   * For example: 81 7e 00 8b 7b 22 69 64 22 3a 32 31 30 32 31 34 31 30\n   * @param {Buffer} buff\n   * @returns {void}\n   */\n  printBuffer(buff) {\n    console.log(buff.toString('hex').match(/../g).join(' '));\n  }\n\n\n}\n\n\n\n\nmodule.exports = new Helper();\n\n},{}],4:[function(require,module,exports){\n/**\n * Subprotocol name: jsonRWS\n * HTTP header: \"Sec-WebSocket-Protocol\": \"jsonRWS\"\n *\n * Subprotocol description:\n *  This subprotocol is created for communication between websocket server and client.\n *\n * Subprotocol definitons:\n *  a) Client have to send message in valid JSON format. Allowed fields: id, from, to, cmd, payload.\n *  b) Server have to send message in valid JSON format. Allowed fields: id, from, to, cmd, payload.\n *  c) The message is converted from string to object.\n */\n\n\nclass JsonRWS {\n\n  constructor() {\n    this.delimiter = '<<!END!>>';\n  }\n\n  /*********** INCOMING MESSAGES ***********/\n  /**\n   * Execute the jsonRWS subprotocol for incoming messages. Filter and map incoming messages.\n   * 1. Test if the message has valid \"jsonRWS\" format {id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}.\n   * 2. Convert the message from string to object.\n   * @param {string} msgSTR -incoming message\n   * @returns {{id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}}\n   */\n  incoming(msgSTR) {\n    let tf = false;\n    let msg;\n    try {\n      msgSTR = msgSTR.replace(this.delimiter, ''); // remove delimiter\n      msg = JSON.parse(msgSTR);\n      const msgObjProperties = Object.keys(msg);\n      tf = this._testFields(msgObjProperties);\n    } catch (err) {\n      tf = false;\n    }\n\n    if (tf) { return msg; }\n    else { throw new Error(`Incoming message doesn\\'t have valid \"jsonRWS\" subprotocol format. msg:: \"${msgSTR}\"`); }\n  }\n\n\n\n  /*********** OUTGOING MESSAGES ***********/\n  /**\n   * Execute the jsonRWS subprotocol for outgoing messages. Filter and map outgoing messages.\n   * 1. Test if the message has valid \"jsonRWS\" format {id:number, from:number, to:number|number[]|string, cmd:string, payload:any}.\n   * 2. Convert the message from object to string.\n   * @param {{id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}} msg - outgoing message\n   * @returns {string}\n   */\n  outgoing(msg) {\n    const msgObjProperties = Object.keys(msg);\n    const tf = this._testFields(msgObjProperties);\n\n    if (tf) {\n      const msgSTR = JSON.stringify(msg) + this.delimiter;\n      return msgSTR;\n    } else {\n      throw new Error(`Outgoing message doesn\\'t have valid \"jsonRWS\" subprotocol format. msg:: ${JSON.stringify(msg)}`);\n    }\n  }\n\n\n\n  /*********** PROCESS MESSAGES ***********/\n  /**\n   * Process client messages internally.\n   * @param {object} msg - instruction message - {id, from, to, cmd, payload}\n   * @param {Socket} socket - client which received the message\n   * @param {DataTransfer} dataTransfer - instance of the DataTransfer\n   * @param {SocketStorage} socketStorage - instance of the SockketStorage\n   * @param {EventEmitter} eventEmitter - event emitter initiated in the RWS.js\n   */\n  async process(msg, socket, dataTransfer, socketStorage, eventEmitter) {\n    const id = msg.id;\n    const from = msg.from;\n    const to = msg.to;\n    const cmd = msg.cmd;\n    const payload = msg.payload;\n\n\n    /*** socket commands ***/\n    if (cmd === 'socket/sendone') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 210201164339351900, cmd: 'socket/sendone', payload: 'Some message to another client'}\n      const id = +msg.to;\n      const toSocket = await socketStorage.findOne({id});\n      dataTransfer.sendOne(msg, toSocket); }\n\n    else if (cmd === 'socket/send') {\n      // {id: 210129163129492000, from: 210129163129492111, to: [210201164339351900, 210201164339351901], cmd: 'socket/send', payload: 'Some message to another client(s)'}\n      const socketIDs = to.map(socketID => +socketID); // convert to numbers\n      const sockets = await socketStorage.find({id: {$in: socketIDs}});\n      dataTransfer.send(msg, sockets); }\n\n    else if (cmd === 'socket/broadcast') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 0, cmd: 'socket/broadcast', payload: 'Some message to all clients except the sender'}\n      dataTransfer.broadcast(msg, socket); }\n\n    else if (cmd === 'socket/sendall') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 0, cmd: 'socket/sendall', payload: 'Some message to all clients and the sender'}\n      dataTransfer.sendAll(msg); }\n\n    else if (cmd === 'socket/nick') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 0, cmd: 'socket/nick', payload: 'Peter Pan'}\n      const nickname = msg.payload;\n      try {\n        await socketStorage.setNick(socket, nickname);\n        msg.payload = socket.extension.nickname;\n      } catch (err) {\n        msg.cmd = 'error';\n        msg.payload = err.message;\n      }\n      socket.extension.sendSelf(msg); }\n\n\n    /*** room commands ***/\n    else if (cmd === 'room/enter') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 0, cmd: 'room/enter', payload: 'My Chat Room'}\n      const roomName = payload;\n      socketStorage.roomEnter(socket, roomName);\n      msg.payload = `Entered in the room '${roomName}'`;\n      socket.extension.sendSelf(msg); }\n\n    else if (cmd === 'room/exit') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 0, cmd: 'room/exit', payload: 'My Chat Room'}\n      const roomName = payload;\n      socketStorage.roomExit(socket, payload);\n      msg.payload = `Exited from the room '${roomName}'`;\n      socket.extension.sendSelf(msg); }\n\n    else if (cmd === 'room/exitall') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 0, cmd: 'room/exitall'}\n      socketStorage.roomExitAll(socket);\n      msg.payload = 'Exited from all rooms';\n      socket.extension.sendSelf(msg); }\n\n    else if (cmd === 'room/send') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 'My Chat Room', cmd: 'room/send', payload: 'Some message to room clients.'}\n      const roomName = to;\n      dataTransfer.sendRoom(msg, socket, roomName); }\n\n\n    /*** route command ***/\n    else if (cmd === 'route') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 0, cmd: 'route', payload: {uri: 'shop/login', body: {username:'mark', password:'thG5$#w'}}}\n      eventEmitter.emit('route', msg, socket, dataTransfer, socketStorage, eventEmitter); }\n\n\n    /*** info commands ***/\n    else if (cmd === 'info/socket/id') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 210129163129492111, cmd: 'info/socket/id'}\n      msg.payload = socket.extension.id;\n      socket.extension.sendSelf(msg); }\n\n    else if (cmd === 'info/socket/list') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 210129163129492111, cmd: 'info/socket/list'}\n      const sockets = await socketStorage.find();\n      const socket_ids_nicks = sockets.map(socket => { return {id: socket.extension.id, nickname: socket.extension.nickname}; });\n      msg.payload = socket_ids_nicks; // {id:number, nickname:string}\n      socket.extension.sendSelf(msg); }\n\n    else if (cmd === 'info/room/list') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 210129163129492111, cmd: 'info/room/list'}\n      const rooms = await socketStorage.roomList();\n      msg.payload = rooms;\n      socket.extension.sendSelf(msg); }\n\n    else if (cmd === 'info/room/listmy') {\n      // {id: 210129163129492000, from: 210129163129492111, to: 210129163129492111, cmd: 'info/room/listmy'}\n      const rooms = await socketStorage.roomListOf(msg.from);\n      msg.payload = rooms;\n      socket.extension.sendSelf(msg); }\n\n  }\n\n\n\n  /******* HELPERS ********/\n  /**\n   * Helper to test msg properties.\n   * @param {string[]} msgObjProperties - propewrties of the \"msg\" object\n   */\n  _testFields(msgObjProperties) {\n    const allowedFields = ['id', 'from', 'to', 'cmd', 'payload'];\n    const requiredFields = ['id', 'from', 'to', 'cmd'];\n    let tf = true;\n\n    // check if every of the msg properties are in allowed fields\n    for (const prop of msgObjProperties) {\n      if (allowedFields.indexOf(prop) === -1) { tf = false; break; }\n    }\n\n    // check if every of required fields is present\n    for (const requiredField of requiredFields) {\n      if(msgObjProperties.indexOf(requiredField) === -1) { tf = false; break; }\n    }\n\n    return tf;\n  }\n\n\n}\n\n\n\nmodule.exports = new JsonRWS();\n\n},{}]},{},[1]);\n"],"file":"client13jsonRWS-min.js"}